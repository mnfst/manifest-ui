# CLAUDE.md

This file provides guidance for Claude Code when working with this repository.

## Project Overview

Manifest UI is a component registry for building MCP (Model Context Protocol) agentic UI components. It is a custom shadcn component registry built with Next.js and Tailwind v4 that allows distributing custom components, hooks, pages, and other files to any React project using the `shadcn` CLI.

## Common Commands

```bash
# Install dependencies
pnpm install

# Development server (uses Turbopack) - port 3001
pnpm run dev

# Build the Next.js app
pnpm run build

# Build the registry (generates static JSON files)
pnpm run registry:build

# Lint
pnpm run lint

# Run tests
pnpm run test
```

## Development Workflow

1. Run `pnpm install` at the root
2. Run `pnpm run dev` to start the registry on port 3001

## Key Files

- `registry.json` - Component registry definitions
- `changelog.json` - Component changelog

## Architecture

### Registry System

The registry is defined in `registry.json` and uses the shadcn registry schema. Each registry item specifies:

- `name`: Component identifier (used in `shadcn add <name>`)
- `type`: Usually `registry:component`
- `files`: Array of file paths with their types (`registry:component`, `registry:page`, `registry:lib`, `registry:hook`)
- `dependencies`: npm packages required
- `registryDependencies`: Other registry items this depends on (e.g., `button`, `card`)

### Directory Structure

- `registry/` - Component blocks organized by category
- `components/ui/` - Base UI primitives (button, card) for local development
- `app/` - Next.js app router pages for previewing components
- `lib/` - Utilities and helpers
- `public/r/[name].json` - Built registry items served as static files (generated by `registry:build`)

### Component Style

Uses shadcn style with:

- Tailwind CSS v4
- CSS variables for theming
- Lucide icons
- Server Components enabled (RSC: true)

### Adding New Components

1. Create component files in `registry/<category>/<component-name>.tsx`
2. Add entry to `registry.json` with proper file paths and dependencies
3. Set initial `version` to `"1.0.0"` for new components
4. Run `pnpm run registry:build` to generate the distributable JSON
5. Import in `app/page.tsx` to preview

## Pull Request Guidelines

**CRITICAL**: When creating pull requests, you MUST use the PR template format from `.github/PULL_REQUEST_TEMPLATE.md`.

### Required PR Body Format

Always structure PR bodies exactly like this:

```markdown
## Summary

<!-- Briefly describe what this PR does and why -->

## Changes

## <!-- List the main changes made in this PR -->

## Type of Change

- [ ] Bug fix (non-breaking change that fixes an issue)
- [ ] New feature (non-breaking change that adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] Refactoring (no functional changes)
- [ ] Documentation update
- [ ] Tests (adding or updating tests)
- [ ] CI/CD (changes to build process or workflows)

## Testing

- [ ] Tests pass locally (`pnpm test`)
- [ ] Lint passes (`pnpm lint`)

## Related Issues

<!-- Link related issues using #123 format, or write "None" if no related issues -->
```

## Files to Never Commit

**CRITICAL**: The following files must NEVER be committed to the repository:

| File                          | Reason                                                               |
| ----------------------------- | -------------------------------------------------------------------- |
| `settings.local.json`         | Local settings file with personal configurations                     |
| `.claude/settings.local.json` | Claude Code local settings                                           |
| `.claude/commands/**`         | Claude Code custom commands (except speckit commands)                |
| `specs/**`                    | Generated specs from speckit (auto-generated, not source-controlled) |

### Exception: Speckit Commands

Speckit-related Claude commands ARE allowed to be committed. These are commands that are part of the project's shared tooling and should be version controlled.

### Before Committing

Always check that staged files do not include:

- Any `settings.local.json` files
- Claude settings or command files (unless they are speckit-related)

## Component Naming Convention (CRITICAL)

**All component names MUST be consistent across registry name, display title, and React export.** This is enforced by tests (`__tests__/component-exports.test.ts`).

### The Rule

The relationship between the three names must follow this deterministic mapping:

| Layer | Format | Example |
|-------|--------|---------|
| Registry `name` | kebab-case | `stat-card` |
| Display `title` | Title Case | `Stat Card` |
| React component export | PascalCase | `StatCard` |
| Props interface export | PascalCase + `Props` | `StatCardProps` |

**The React component name MUST be the PascalCase version of the registry `name`.** No abbreviations, no synonyms, no creative alternatives.

### Known Exceptions

Some components have brand-specific casing that cannot follow simple kebab-to-PascalCase conversion. These are tracked in the `NAMING_VARIATIONS` map in `__tests__/component-exports.test.ts`:

| Registry Name | Component Export | Reason |
|---|---|---|
| `linkedin-post` | `LinkedInPost` | Brand name "LinkedIn" has internal capital |
| `youtube-post` | `YouTubePost` | Brand name "YouTube" has internal capital |
| `x-post` | `XPost` | Single-letter brand name |

### Examples

```typescript
// ✅ CORRECT - Registry name "contact-form" → component "ContactForm"
export interface ContactFormProps { ... }
export function ContactForm(props: ContactFormProps) { ... }

// ✅ CORRECT - Registry name "map-carousel" → component "MapCarousel"
export interface MapCarouselProps { ... }
export function MapCarousel(props: MapCarouselProps) { ... }

// ❌ WRONG - Registry name "stat-card" but component "Stats" (inconsistent)
export interface StatsProps { ... }
export function Stats(props: StatsProps) { ... }

// ✅ FIXED - Registry name "stat-card" → component "StatCard"
export interface StatCardProps { ... }
export function StatCard(props: StatCardProps) { ... }
```

### Checklist for New Components

Before creating a component:

1. Choose the kebab-case registry name (e.g., `my-component`)
2. The display title is the Title Case version (e.g., `My Component`)
3. The component export MUST be the PascalCase version (e.g., `MyComponent`)
4. The props interface MUST be `{ComponentName}Props` (e.g., `MyComponentProps`)
5. If the name contains a brand with non-standard casing, add it to `NAMING_VARIATIONS`

## Component Props Interface Convention

**IMPORTANT**: All registry block components MUST follow this Props interface naming and documentation convention. Tests enforce these rules (`__tests__/props-jsdoc.test.ts`, `__tests__/component-exports.test.ts`).

### Naming Convention

Every exported component must have a corresponding Props interface named `{ComponentName}Props`:

```typescript
// For a component named "Table"
export interface TableProps { ... }
export function Table(props: TableProps) { ... }

// For a component named "PaymentMethods"
export interface PaymentMethodsProps { ... }
export function PaymentMethods(props: PaymentMethodsProps) { ... }
```

### Standard Props Structure

All component Props interfaces should use the semantic 4-category structure: `data`, `actions`, `appearance`, `control`.

### JSDoc Requirements

Props interfaces require two types of documentation:

1. **Decorative header comment** above the interface with ═══ characters
2. **JSDoc comments on each sub-parameter** inside data/actions/appearance/control

**DO NOT** put comments on the category properties themselves (data, actions, appearance, control).

```typescript
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * ComponentNameProps
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Props for the ComponentName component.
 * Brief description of what the component does.
 */
export interface ComponentNameProps {
  data?: {
    /** Array of items to display in the list. */
    items?: Item[]
    /** Optional title displayed above the list. */
    title?: string
  }
  actions?: {
    /** Called when a user selects an item from the list. */
    onSelect?: (item: Item) => void
    /** Called when the form is submitted. */
    onSubmit?: () => void
  }
  appearance?: {
    /**
     * Layout variant for the component.
     * @default "default"
     */
    variant?: 'default' | 'compact'
    /**
     * Whether to show the header section.
     * @default true
     */
    showHeader?: boolean
  }
  control?: {
    /** Whether the component is in loading state. */
    loading?: boolean
    /** ID of the currently selected item for controlled selection. */
    selectedId?: string
  }
}
```

### JSDoc Best Practices

- Use `@default` tags for properties with default values
- Keep descriptions concise but meaningful
- For complex types, explain the expected structure
- For callbacks, explain when they are triggered

These comments make documentation visible in IDE hover tooltips, improving developer experience.

## Block Development Guidelines

**CRITICAL**: When adding or editing a block, you MUST update ALL related code across the codebase.

### Complete Update Requirement (CRITICAL)

**When modifying ANY aspect of a block, you MUST update EVERY place that references it.**

A block modification is NOT complete until you have updated:

| Location                                 | What to Update                                                              |
| ---------------------------------------- | --------------------------------------------------------------------------- |
| `registry/<category>/<block>.tsx`        | Component code, interfaces, props (NO default data in component!)           |
| `registry/<category>/demo/data.ts`       | Centralized demo data for previews (single source of truth)                 |
| `app/blocks/[category]/[block]/page.tsx` | `usageCode`, component preview, block metadata (imports from demo/data.ts)  |
| `registry.json`                          | Version bump (PATCH/MINOR/MAJOR), category field (auto-derived from folder) |
| `changelog.json`                         | Changelog entry for the new version                                         |

**Note**: The `category` field in `registry.json` is automatically derived from the folder name (e.g., `registry/form/` → `category: "form"`). When adding a new component, place it in the correct folder and the category will be set automatically.

#### What Lives in `page.tsx`

The block detail page (`app/blocks/[category]/[block]/page.tsx`) contains:

1. **Block metadata** - `id`, `name`, `description`, `registryName`, `layouts`, `actionCount`
2. **Variants array** - Each variant has:
   - `id`, `name` - Variant identifier and display name
   - `component` - The actual React component with props for preview
   - `usageCode` - **String** that developers copy-paste (MUST match the component interface exactly)
3. **Default data** - Sample data used in the preview

#### Common Mistakes to Avoid

- Changing a prop name in the `.tsx` file but forgetting to update `usageCode`
- Removing a prop from the interface but leaving it in `usageCode`
- Adding a new required prop but not showing it in `usageCode`
- Updating default values in the component but not reflecting them in preview data

#### Verification Steps

After ANY component change:

1. Read the component `.tsx` file to understand the current interface
2. Read the `page.tsx` block definition to see current `usageCode`
3. Ensure `usageCode` exactly matches the component's interface
4. Ensure the preview component uses the correct props
5. Bump version in `registry.json`
6. Add changelog entry in `changelog.json`

### Required Files to Update

When creating or modifying a block, update these files:

1. **Component file**: `registry/<category>/<block-name>.tsx`
2. **Demo data file**: `registry/<category>/demo/data.ts` (centralized demo data)
3. **Registry definition**: `registry.json`
4. **Block demo with usage example**: `app/blocks/[category]/[block]/page.tsx`
5. **Preview components**: `lib/preview-components.tsx` (imports from demo/data.ts)
6. **Sidebar navigation** (if new block): `app/blocks/page.tsx`
7. **Category navigation** (if new): `lib/blocks-categories.ts`

### Display Modes Pattern (CRITICAL)

**ALL components in this registry MUST support all 3 display modes.** This is a fundamental architecture requirement, not optional:

| Mode | Description | Layout |
|------|-------------|--------|
| `inline` | Compact view within chat flow | Horizontal card, truncated content |
| `pip` | Picture-in-picture floating view | Similar to inline, optimized for floating |
| `fullscreen` | Full-page expanded view | Complete content, vertical scroll |

**Implementation:**
- Accept `displayMode` in the `appearance` prop
- Render different layouts based on the mode
- Integrate with ChatGPT/MCP host API for real environments

### No Default Data Pattern (CRITICAL)

**Components MUST NOT have hardcoded default data.** They should only render what the user explicitly provides.

```typescript
// ❌ BAD - Don't use default data in components
const post = data?.post ?? { title: 'Default Title' };

// ✅ GOOD - Only render what's provided
const post = data?.post;
return post?.title && <h1>{post.title}</h1>;
```

**Why:**
- Users expect empty components until they provide data
- Default data creates confusion about required vs optional fields
- Demo data belongs in `demo/data.ts`, not in the component

**Note:** While components don't use *inline* hardcoded defaults, they DO import centralized demo data and use `data ?? demoData` so that `<Component />` renders meaningful content. See the "Component Demo Data Initialization" section above for the full pattern.

### Centralized Demo Data Pattern (CRITICAL)

All demo data MUST live in `registry/<category>/demo/data.ts`:

```
registry/blogging/
├── post-detail.tsx     # Component (NO default data)
├── types.ts            # TypeScript interfaces
└── demo/
    └── data.ts         # All demo data (single source of truth)
```

Both `page.tsx` and `preview-components.tsx` import from `demo/data.ts`. Never duplicate demo data.

### Avatar Pattern (IMPORTANT)

**All components with avatars MUST support both image URLs and letter fallbacks.**

When a component displays an avatar (e.g., in messaging, comments, profiles), implement this pattern:

```typescript
// In the component's data interface
data?: {
  avatarUrl?: string       // Image URL (optional, takes priority over letter)
  avatarFallback?: string  // Letter fallback (e.g., "S" for Sarah)
  // ... other props
}
```

**Implementation:**

- If `avatarUrl` is provided and loads successfully → show the image
- If `avatarUrl` fails to load OR is not provided → show letter in a colored circle
- Always require `avatarFallback` (letter) as the fallback

### Usage Example Requirements

Every block variant in `app/blocks/[category]/[block]/page.tsx` MUST have a `usageCode` field with a comprehensive example that demonstrates:

1. **All common props** - Show the typical props a developer would use
2. **Realistic demo data** - Use meaningful placeholder data, not just "test" or "foo"
3. **Action handlers** - Include `console.log` examples for all actions
4. **Proper prop categories** - Use the standard `data`, `actions`, `appearance`, `control` structure

### Props Structure Pattern

All blocks follow this consistent props pattern:

```typescript
export interface BlockProps {
  data?: {
    // Content/configuration - titles, items, amounts, etc.
  };
  actions?: {
    // Event handlers - onSubmit, onClick, onSelect, etc.
  };
  appearance?: {
    // Visual/styling - variant, currency, columns, theme, etc.
  };
  control?: {
    // State/loading - isLoading, value, disabled, etc.
  };
}
```

### Version Bump Requirements (CRITICAL)

**Every modification to a block's source files MUST include a version bump in `registry.json`.**

This is enforced by automated tests that will fail if:

1. You modified any file in `registry/**/*.tsx`
2. But did NOT update the corresponding component's `version` in `registry.json`

#### Semantic Versioning Guide

| Change Type | Version Bump      | Examples                                                     |
| ----------- | ----------------- | ------------------------------------------------------------ |
| **PATCH**   | `1.0.0` → `1.0.1` | Bug fixes, styling fixes, refactoring without API changes    |
| **MINOR**   | `1.0.0` → `1.1.0` | New features, new optional props, new variants               |
| **MAJOR**   | `1.0.0` → `2.0.0` | Breaking changes: removing/renaming props, changing behavior |

### Changelog Requirements (CRITICAL)

**Every version MUST have a corresponding changelog entry in `changelog.json`.**

This is enforced by automated tests that will fail if:

1. A component has a version in `registry.json`
2. But does NOT have a changelog entry for that version in `changelog.json`

#### Changelog File Structure

The changelog is stored in `changelog.json`:

```json
{
  "components": {
    "component-name": {
      "1.0.0": "Initial release with core features",
      "1.0.1": "Fixed a display issue on mobile devices",
      "1.1.0": "Added new compact variant"
    }
  }
}
```

#### Changelog Entry Guidelines

1. **Keep it simple** - One sentence, non-technical if possible
2. **Focus on user impact** - What changed from the user's perspective
3. **Be specific** - Avoid vague descriptions like "bug fixes"

### Category Requirements (CRITICAL)

**Every component MUST have a `category` field in `registry.json`.**

The category is automatically derived from the folder structure:

- File path: `registry/form/date-time-picker.tsx`
- Category: `form`

#### Available Categories

| Folder                    | Category        | URL Example                         |
| ------------------------- | --------------- | ----------------------------------- |
| `registry/blogging/`      | `blogging`      | `/blocks/blogging/post-card`        |
| `registry/events/`        | `events`        | `/blocks/events/event-card`         |
| `registry/form/`          | `form`          | `/blocks/form/contact-form`         |
| `registry/list/`          | `list`          | `/blocks/list/table`                |
| `registry/messaging/`     | `messaging`     | `/blocks/messaging/message-bubble`  |
| `registry/miscellaneous/` | `miscellaneous` | `/blocks/miscellaneous/quick-reply` |
| `registry/payment/`       | `payment`       | `/blocks/payment/card-form`         |

### Events Category Guidelines (CRITICAL)

**When creating or modifying Events category components, follow these guidelines:**

#### Event Data Structure

All event components use a shared `Event` interface:

```typescript
type EventLocationType = 'physical' | 'online' | 'hybrid';

interface Event {
  id: string;
  title: string;
  category: string; // "Music", "Comedy", "Classes", "Nightlife", "Sports"
  locationType?: EventLocationType; // defaults to "physical"
  venue?: string; // Optional for online events
  neighborhood?: string;
  city?: string; // Optional for online events
  onlineUrl?: string; // For online/hybrid events
  startDateTime: string; // ISO format: "2025-01-11T21:00:00Z"
  endDateTime?: string; // ISO format: "2025-01-12T03:00:00Z"
  priceRange: string; // "$45 - $150", "Free"
  image?: string;
  vibeTags?: VibeTag[]; // ["High energy", "Late night", "Dressy"]
  vibeDescription?: string;
  aiSummary?: string; // AI-generated match explanation
  lineup?: string[];
  eventSignal?: EventSignal;
  ticketSignal?: TicketSignal;
  organizerRating?: number;
  reviewCount?: number;
  hasMultipleDates?: boolean;
  discount?: string;
}
```

#### Signal Types

**Event Signals** - Status indicators for events:

```typescript
type EventSignal =
  | 'going-fast' | 'popular' | 'just-added' | 'sales-end-soon'
  | 'few-tickets-left' | 'canceled' | 'ended' | 'postponed';
```

**Ticket Signals** - Status indicators for ticket availability:

```typescript
type TicketSignal =
  | 'discount-applied' | 'few-tickets-left' | 'less-than-10-remaining'
  | 'more-than-11-remaining' | 'not-yet-on-sale' | 'sales-end-soon'
  | 'sales-ended' | 'sold-out' | 'unavailable' | 'unlocked';
```

### PostList Block Requirements (CRITICAL)

**The PostList block MUST always have exactly 15 posts in its `usageCode` data.**

This is required because:

1. The PostList component does NOT have default posts - it requires data to be passed
2. Users copy-paste the usage code to test in MCP Jam - they need complete data
3. 15 posts provides a realistic dataset for pagination and scrolling demos

### Checklist for Block Changes

Before submitting a PR with block changes:

**Synchronization (CRITICAL):**

- [ ] **Component interface matches `usageCode`** - Every prop in the interface is shown in usageCode
- [ ] **`usageCode` uses correct prop names** - No stale/renamed props in usageCode
- [ ] **Preview component uses current props** - The `<Component />` in variants uses the right props
- [ ] **Default values are consistent** - Defaults in component match what's shown in preview

**Versioning (REQUIRED):**

- [ ] **Version bumped in `registry.json`** (tests will fail otherwise)
- [ ] **Changelog entry added in `changelog.json`** (tests will fail otherwise)

**Quality:**

- [ ] Component implements the standard props pattern (`data`, `actions`, `appearance`, `control`)
- [ ] Block is registered in `registry.json` with correct dependencies
- [ ] EVERY variant has a `usageCode` field with comprehensive example
- [ ] Usage example shows realistic data (not placeholder text like "test" or "foo")
- [ ] All action handlers are demonstrated with `console.log` examples
- [ ] New category added to `blocks-categories.ts` if needed
- [ ] **PostList block has exactly 15 posts in usageCode** (if modifying PostList)

## SEO Guidelines for ui.manifest.build

This project powers https://ui.manifest.build. Follow these SEO best practices:

### Automated SEO Tests

SEO requirements are enforced by tests in `__tests__/seo.test.ts`. Run `pnpm test` to verify:

- Meta tags configuration
- Sitemap and robots.txt presence
- Structured data (JSON-LD)
- Heading hierarchy
- Image alt text

### Key SEO Files

| File                    | Purpose                                  |
| ----------------------- | ---------------------------------------- |
| `app/layout.tsx`        | Global metadata, JSON-LD structured data |
| `app/sitemap.ts`        | Dynamic sitemap generation               |
| `app/robots.ts`         | Crawler directives                       |
| `app/blocks/layout.tsx` | /blocks page metadata                    |

### When Adding New Pages

1. **Add page-specific metadata** using Next.js Metadata API
2. **Update sitemap.ts** to include the new route
3. **Use semantic HTML** - one `<h1>` per page, proper heading hierarchy
4. **Add alt text** to all images

### When Modifying Existing Pages

1. **Preserve heading structure** - don't remove or duplicate `<h1>`
2. **Keep alt text** on images descriptive and relevant
3. **Run SEO tests** before committing: `pnpm test`

### Image Best Practices

- Always include descriptive `alt` attributes
- Use Next.js `Image` component when possible for optimization
- Keep OG images under 100KB

## Analytics Tracking (Vercel)

**IMPORTANT**: When adding or updating blocks, maintain Vercel Analytics tracking for user interactions.

### Pricing Constraint

**CRITICAL**: Our Vercel plan includes custom events with **maximum 2 properties per event**. Additional events beyond the plan limit cost $30 per 1M events. Always limit tracking to 2 properties maximum.

### Existing Tracking Events

The following events are tracked via `@vercel/analytics`:

| Event Name | Properties (max 2) | Location |
|-----------|------------|----------|
| `install_command_copied` | `{ command, inline: boolean }` | `components/blocks/install-commands.tsx`, `components/blocks/install-command-inline.tsx` |
| `code_copied` | `{ code }` | `components/blocks/code-block.tsx` |

### When Adding New Blocks

1. **Use existing components**: When displaying install commands, use `<InstallCommands>` or `<InstallCommandInline>` components - they already have tracking built-in
2. **Use CodeBlock for code display**: The `<CodeBlock>` component tracks code copies automatically
3. **New interaction types**: If adding a new type of user interaction (not copy), add tracking using:
   ```tsx
   import { track } from '@vercel/analytics'

   // Track the event - MAXIMUM 2 PROPERTIES
   track('event_name', { property1: 'value1', property2: 'value2' })
   ```
4. **Consistency**: Keep event names snake_case and properties descriptive
5. **Property limit**: Never exceed 2 properties per event to stay within the Vercel Analytics free tier
